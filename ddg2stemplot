#!/usr/bin/env python

#    ddg2matrix: plot DDG MutateX results as heat maps.
#    Copyright (C) 2015, Matteo Tiberti <matteo.tiberti@gmail.com> (and Thilde Bagger Terkelsen <ThildeBT@gmail.com>)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.






# Imports
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib import cm
import argparse
import logging as log
from Bio import PDB





parser = argparse.ArgumentParser(
description='FoldX Stemplot',)

cmaps_list = [m for m in cm.datad if not m.endswith("_r")]

parser.add_argument("-p","--pdb", dest="in_pdb", help="Input pdb file")
parser.add_argument("-d","--data-directory", dest="input_path", type=str, help="input data directory")
parser.add_argument("-l","--mutation_list", dest="mutations",  help="mutation_list")
parser.add_argument("-o","--output", dest="outfile", type=str, default='stemplot')
parser.add_argument("-i","--title", dest='title', type=str, default='stemplot', help="Title for the output image file")
parser.add_argument("-c","--color-map",dest='cmap', type=unicode, default="jet", help="Color map used to plot the DDG values (choose from: %s)" % ", ".join(cmaps_list))
parser.add_argument("-s","--splice",dest='sv',action='store', type=int, default=20, help="Number of residues for each single image")

options = parser.parse_args()




three2one = {'ALA':'A',
             'CYS':'C',
             'ASP':'D',
             'GLU':'E',
             'PHE':'F',
             'GLY':'G',
             'HIS':'H',
             'ILE':'I',
             'LYS':'K',
             'LEU':'L',
             'MET':'M',
             'ASN':'N',
             'PRO':'P',
             'GLN':'Q',
             'ARG':'R',
             'SER':'S',
             'THR':'T',
             'VAL':'V',
             'TRP':'W',
             'TYR':'Y'}


if options.cmap not in cmaps_list:
    log.error("Specified color map is not available. Choose one between: %s." % ", ".join(cmaps_list) )
    exit(1)




pdb_parser = PDB.PDBParser()

try:
    user_structure = pdb_parser.get_structure('s', options.in_pdb)
except:
    log.error("Couldn't open or parse input pdb file. Exiting...")
    exit(1)




try:
    fh = open(options.mutations, 'r')
except:
    log.warning("mutationlist cannot be opened.")
muts = []
for line in fh:
    mut = line.rstrip()
    muts.append(mut)







def parse_file(fname, index_as_float):

    try:
        fh = open(fname, 'r')
        next(fh)
    except:
        log.warning("file %s cannot be opened." % fname)
        return None

    values =[]

    alist = [float(line.split()[0]) for line in fh]
    values.append(alist)

    if len(values[0]) != len(muts):
        log.error("file %s has %d values, with %d required. Exiting..." % (fname, len(values[0]), len(muts)))
        exit(1)


    res_IDs = fname.rsplit('/', 1)[-1]

    mean_val = float(np.average(values))

    ste = float(np.std(values)/np.sqrt(len(values[0])))

    return [index_as_float, mean_val, ste, res_IDs]








def pdbmodel(structure):

    res_ids = []
    res_ids_str = []
    data = []

    models = structure.get_list()

    if len(models) > 1:
        log.warning("%d models are present in the input PDB file; only the first will be used." % len(models))
    if len(models) < 1:
        log.error("The input PDB file does not contain any model. Exiting ...")
        exit(1)

    model = models[0]

    for chain in model:
        for res in chain:
            try:
                this_type = three2one[res.get_resname()]
            except:
                log.warning("residue %s, %s, %d not recognized. It will be skipped." % (res.get_resname(), chain.get_id(), res.get_id()[1]))
                continue

            res_ids.append((chain.get_id(), res.get_id()[1], this_type))
            res_ids_str.append("%s%s%d" % (res_ids[-1][2],res_ids[-1][0],res_ids[-1][1]))

    for i, j in enumerate(res_ids_str):
        iflo = float(i)
        this_data = parse_file("%s/%s" % (options.input_path, res_ids_str[i]), iflo)
        data.append(this_data)

    data = np.array(data, dtype=object)
    data = np.transpose(data)

    return data






def splice_data(data, sv):

    out = []

    if data.shape[1] <= sv:
        return [data]

    nsplice = data.shape[1] / int(sv)
    rest = data.shape[1] % int(sv)

    if rest != 0:
        nsplice += 1

    for i in range(nsplice):
        out.append([data[0][i*sv:(i+1)*sv:], data[1][i*sv:(i+1)*sv:], data[2][i*sv:(i+1)*sv:], data[3][i*sv:(i+1)*sv:]])

    return out





user_data = splice_data(pdbmodel(user_structure), options.sv)





def stemplot(data, outfile, title, cmap):
    for i in range(len(data)):

        color_by = data[i][1]
        color_by = color_by.tolist()
        
        try:
          plt.style.use('ggplot')
        except:
          continue
        finally:
          fig = plt.figure()
          ax = plt.subplot(111)
          sc = ax.scatter(data[i][0], data[i][1], s=100, c=color_by, marker='o', edgecolors='grey', cmap=cm.get_cmap(cmap), alpha=1)
          ax.errorbar(data[i][0], data[i][1], yerr=data[i][2], ls='None', color='grey')
          ax.set_title(title)
          ax.set_xlabel('Wild-type Amino Acids')
          ax.set_ylabel(r'Mean FoldX $\Delta\Delta{}G (kcal/mol)$')
          plt.xticks(data[i][0], data[i][3], rotation='vertical')
          plt.colorbar(sc)
          plt.savefig(outfile+'_%s.pdf' %i, bbox_inches='tight')
          plt.clf()



stemplot(user_data, options.outfile, options.title, options.cmap)
