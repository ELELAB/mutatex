#!/usr/bin/env python

#    ddg2matrix: plot DDG MutateX results as heat maps.
#    Copyright (C) 2015, Matteo Tiberti <matteo.tiberti@gmail.com> (and Thilde Bagger Terkelsen <ThildeBT@gmail.com>)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import matplotlib
matplotlib.use('Agg')
matplotlib.rcParams['savefig.format'] = u'pdf'
import argparse
from scipy.stats.kde import gaussian_kde
from numpy import linspace
from pylab import plot, hist
import logging as log
from matplotlib import pyplot as plt
import numpy as np
from Bio import PDB

#Add extra ptm residues to PDB.Polypeptide three to one module 
ptm_residues = {"y": "PTR",
                "p": "TPO",
                "s": "SEP",
                "h": "HYP",
                "z": "TYS",
                "k": "MLZ",
                "m": "MLY",
                "l": "M3L",
                "o": "H1S",
                "e": "H2S",
                "f": "H3S"}
len_three2one = len(PDB.Polypeptide.d1_to_index)
idx=len_three2one
for k,v in ptm_residues.iteritems():
    PDB.Polypeptide.d1_to_index[k] = idx
    PDB.Polypeptide.dindex_to_1[idx] = k
    
    PDB.Polypeptide.d3_to_index[v] = idx
    PDB.Polypeptide.dindex_to_3[idx] = v
    idx += 1



def parse_file(fname):

    try:
        fh = open(fname, 'r')
    except:
        log.warning("file %s cannot be opened." % fname)
        return None

    values =[]
    for line in fh:
        if line and not line.startswith("#"):
            values.append(float(line.split()[0]))

    if len(values) != len(muts):
        log.error("file %s has %d values, with %d required. Exiting..." % (fname, len(values), len(muts)))
        exit(1)

    return(values)

def get_residue_list(structure, multimers=True):

    models = structure.get_list()

    if len(models) > 1:
        log.warning("%d models are present in the input PDB file; only the first will be used." % len(models))
    if len(models) < 1:
        log.error("The input PDB file does not contain any model. Exiting ...")
        exit(1)

    model = models[0]

    residue_list = []
    sequences = {}

    for chain in model:
        chain_name = chain.get_id()
        sequences[chain_name] = ''
        for residue in chain:
            try:
                res_code = PDB.Polypeptide.three_to_one(residue.get_resname())
            except:
                log.warning("Residue %s in file %s couldn't be recognized; it will be skipped" %(residue, options.in_pdb))
                continue
            if not multimers:
                residue_list.append(("%s%s%d") % (res_code, chain.get_id(), residue.get_id()[1]))
            else:
                sequences[chain_name] += res_code

    if options.multimers:
        collated_chains = []
        seq_ids, seqs = zip(*list(sequences.iteritems()))
        seq_ids = np.array(seq_ids)
        unique_seqs, unique_idxs = np.unique(seqs, return_inverse=True)

        for i in np.unique(unique_idxs):
            collated_chains.append(seq_ids[unique_idxs == i])

        for cg in collated_chains:
            for model in structure:
                for residue in model[cg[0]]:
                    resid = residue.get_id()[1]
                    try:
                        res_code = PDB.Polypeptide.three_to_one(residue.get_resname())
                    except:
                        log.warning("Residue %s in file %s couldn't be recognized; it will be skipped" %(residue, options.in_pdb))
                        continue
                    residue_list.append(tuple([ "%s%s%d" % (res_code, c, resid) for c in cg ]))
    return residue_list

def pdbmodel(residue_list, d):

#     res_ids = []
#     res_ids_str = []
    data = []
    remove =  []

#     res_ids.append((chain.get_id(), res.get_id()[1], this_type))
    if options.multimers:
        res_ids_str = ["_".join(r) for r in residue_list]
    else:
        res_ids_str = residue_list
        
    res_restypes = [r[0][0] for r in residue_list]

    #Make remove array
#     remove = [d[r] for r in res_restypes]
    
    for fname in res_ids_str:
        this_data = parse_file("%s/%s" % (options.input_path, fname))
        data.append(np.array(this_data))

    positions = []
    for i,r in enumerate(res_restypes):
        if r in d:
            remove.append(d[r])
            positions.append(i)

    data = np.vstack(data)

    N, K = data.shape[0], data.shape[1]
    mask = np.ones_like(data, dtype='bool')
    mask[[positions, remove]] = 0
    data = data[mask].reshape(N, K-1)
    data = data.tolist()
    data = [item for sublist in data for item in sublist]
    return data

def densityplot(data, outfile, title, mycolor):
    try:
        plt.style.use('ggplot')
    except:
        print("ggplot-grid not avalible continuing without")
    finally:
        fig = plt.figure()
	KDE = gaussian_kde(data)
    xmin = -5
    xmax = 10
    spaces = 150
    x = linspace(xmin,xmax,spaces)
    KDV = [KDE(i)[0] for i in linspace(xmin, xmax, spaces)]
    np.savetxt(options.kdvfile, zip(x,KDV), fmt='%.3f', newline='\n', header='xaxis, kdv', footer='', comments='# ')
    plot(x,KDE(x),'r', c=mycolor)
    hist(data, int(len(data)/10) , normed=1,alpha=.3, facecolor=mycolor)
    plt.xlabel(r'FoldX $\Delta\Delta{}G (kcal/mol)$')
    plt.ylabel('Density')
    if title is not None:
        plt.title(title)
    plt.savefig(outfile, bbox_inches='tight')
    plt.clf()

parser = argparse.ArgumentParser(description='Generate probability density via kernel density estimation of the calculated DDG',)

parser.add_argument("-p","--pdb", dest="in_pdb", help="Input pdb file")
parser.add_argument("-d","--data-directory", dest="input_path", type=str, help="input data directory")
parser.add_argument("-l","--mutation_list", dest="mutations",  help="mutation_list")
parser.add_argument("-o","--output", dest="outfile", type=str, default="densityplot.pdf")
parser.add_argument("-i","--title", dest='title', type=str, default=None, help="Title for the output image file")
parser.add_argument("-c","--color", dest='mycolor', type=unicode, default="blue", help="Color used to plot the DDG values")
parser.add_argument("-u","--ddgfile", dest="ddgfile.dat", type=str, default="ddgvalues.dat", help="File containing all the used DDG values")
parser.add_argument("-k","--kdvfile", dest="kdvfile.dat", type=str, default="kdvvalues.dat", help="File containing calculated density values")
parser.add_argument("-M","--multimers", dest="multimers", default=True, action='store_false')

options = parser.parse_args()

pdb_parser = PDB.PDBParser()

try:
    user_structure = pdb_parser.get_structure('s', options.in_pdb)
except:
    log.error("Couldn't open or parse input pdb file. Exiting...")
    exit(1)

try:
    fh = open(options.mutations, 'r')
except:
    log.warning("mutationlist cannot be opened.")
muts = []
for line in fh:
    mut = line.rstrip()
    muts.append(mut)
d = {}
for value in muts:
    d[value] = muts.index(value)

residue_list = get_residue_list(user_structure, multimers=options.multimers)

user_data = pdbmodel(residue_list, d)

ddgvalues = np.asarray(user_data)

np.savetxt(options.ddgfile, ddgvalues, fmt='%.3f', newline='\n', header='DDG', footer='', comments='# ')

densityplot(user_data, options.outfile, options.title, options.mycolor)
